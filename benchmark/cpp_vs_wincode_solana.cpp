/**
 * @file cpp_vs_wincode_solana.cpp
 * @brief C++ limcode vs Rust wincode on REAL Solana transaction data
 */

#include <limcode/limcode.h>
#include <chrono>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <vector>
#include <cstdint>

using namespace std::chrono;

std::vector<uint8_t> read_file(const char* filename) {
    std::ifstream file(filename, std::ios::binary | std::ios::ate);
    if (!file) {
        throw std::runtime_error(std::string("Failed to open ") + filename);
    }

    std::streamsize size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<uint8_t> buffer(size);
    if (!file.read(reinterpret_cast<char*>(buffer.data()), size)) {
        throw std::runtime_error(std::string("Failed to read ") + filename);
    }

    return buffer;
}

double benchmark_serialize(const std::vector<uint8_t>& data, size_t iterations, const char* label) {
    std::vector<uint8_t> output;

    // Warmup
    for (size_t i = 0; i < 100; ++i) {
        limcode::serialize_pod_into(output, data);
    }

    // Benchmark
    auto start = high_resolution_clock::now();
    for (size_t i = 0; i < iterations; ++i) {
        limcode::serialize_pod_into(output, data);
        volatile uint8_t sink = output[0];
        (void)sink;
    }
    auto end = high_resolution_clock::now();

    double ns_per_op = duration_cast<nanoseconds>(end - start).count() / static_cast<double>(iterations);
    double throughput_gbps = (data.size() / ns_per_op);

    std::cout << std::left << std::setw(30) << label
              << std::right << std::setw(8) << data.size() << " B  "
              << std::setw(10) << std::fixed << std::setprecision(2)
              << throughput_gbps << " GB/s  "
              << std::setw(8) << std::fixed << std::setprecision(2)
              << ns_per_op << " ns\n";

    return throughput_gbps;
}

int main() {
    std::cout << "\n═══════════════════════════════════════════════════════════════\n";
    std::cout << "  C++ Limcode on Real Solana Transaction Bytes\n";
    std::cout << "═══════════════════════════════════════════════════════════════\n\n";

    try {
        // Read real Solana transaction (generated by Rust)
        auto tx_bytes = read_file("/tmp/solana_tx_bincode.bin");

        std::cout << "Real Solana Transaction: " << tx_bytes.size() << " bytes\n";
        std::cout << "First 32 bytes: [";
        for (size_t i = 0; i < 32 && i < tx_bytes.size(); ++i) {
            if (i > 0) std::cout << ", ";
            printf("%02x", tx_bytes[i]);
        }
        std::cout << "]\n\n";

        std::cout << std::left << std::setw(30) << "Benchmark"
                  << std::right << std::setw(8) << "Size" << "    "
                  << std::setw(10) << "Throughput" << "  "
                  << std::setw(8) << "Latency" << "\n";
        std::cout << std::string(70, '-') << "\n";

        // Single transaction
        benchmark_serialize(tx_bytes, 10000000, "Single TX (10M iterations)");

        // Simulate batch by repeating
        std::vector<uint8_t> batch_10;
        for (int i = 0; i < 10; ++i) {
            batch_10.insert(batch_10.end(), tx_bytes.begin(), tx_bytes.end());
        }
        benchmark_serialize(batch_10, 1000000, "Batch 10 TXs (1M iters)");

        std::vector<uint8_t> batch_100;
        for (int i = 0; i < 100; ++i) {
            batch_100.insert(batch_100.end(), tx_bytes.begin(), tx_bytes.end());
        }
        benchmark_serialize(batch_100, 100000, "Batch 100 TXs (100K iters)");

        std::vector<uint8_t> batch_1000;
        for (int i = 0; i < 1000; ++i) {
            batch_1000.insert(batch_1000.end(), tx_bytes.begin(), tx_bytes.end());
        }
        benchmark_serialize(batch_1000, 10000, "Batch 1000 TXs (10K iters)");

        std::cout << "\n═══════════════════════════════════════════════════════════════\n";
        std::cout << "  Compare these results with Rust wincode benchmarks\n";
        std::cout << "  (Run: cargo bench --bench solana_limcode_vs_wincode)\n";
        std::cout << "═══════════════════════════════════════════════════════════════\n\n";

    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << "\n";
        std::cerr << "Make sure to run: cargo run --example solana_bincode_test first\n";
        return 1;
    }

    return 0;
}
